#ifndef MY_TREE_H
#define MY_TREE_H
#include <iostream>
#include <vector>
#include <stack>
#include "queue"
using namespace std;
template <class T>
class MyTree {

private:

    struct node {
        T item;
        node* left;
        node* right;
    };

    node* root;

public:
    MyTree() {
        root = NULL;
    }

    MyTree(vector<T> elements) {
        for (int i = 0; i < elements.size(); i++)
            insert(elements);
    }

    bool search(T key) {
        node* p = root;
        if (p == NULL)
            return;

        while (p != NULL) {
            if (key == p->item)
                return true;
            if (key > p->item) {
                p = p->right;
            }
            else
                p = p->left;
        }
        return false;
    }

    void insert(T key) {


        node* newnode = newNode(key);

        node* x = root;

        node* y = NULL;

        while (x != NULL) {
            y = x;
            if (key < x->item)
                x = x->left;
            else if (key > x->item)
                x = x->right;
            else
                return;
        }


        if (root == NULL)
        {
            root = newnode;
        }


        else if (key < y->item)
            y->left = newnode;


        else
            y->right = newnode;


        Node* newNode(T data)
        {
            node* temp = new Node;

            temp->item = data;

            temp->left = NULL;
            temp->right = NULL;

            return temp;
        }
    }
    void inorder_rec(node* p) {
        p = root;
        if (p != NULL)
        {
            inorder_rec(p->left);
            cout << p->info << " ";
            inorder_rec(p->right);
        }
    }

    void preorder_rec(node* p) {
        p = root;
        if (p != NULL)
        {
            cout << p->info << " ";
            preorder_rec(p->left);
            preorder_rec(p->right);
        }
    }

    void postorder_rec(node* p) {
        p = root;
        if (p != NULL)
        {
            postorder_rec(p->left);
            postorder_rec(p->right);
            cout << p->info << " ";
        }
    }

    void inorder_it() {
        stack<node*> s;
        node* curr = root;

        while (curr != NULL || s.empty() == false)
        {
            while (curr != NULL)
            {
                s.push(curr);
                curr = curr->left;
            }

            curr = s.top();
            s.pop();

            cout << curr->item << " ";
            curr = curr->right;

        }
    }

    void preorder_it(node* p) {
        {
            p = root;
            if (p == NULL)
                return;

            stack<node*> nodeStack;
            nodeStack.push(p);

            while (nodeStack.empty() == false) {
                struct node* node = nodeStack.top();
                cout << node->item << " ";
                nodeStack.pop();

                
                if (node->right)
                    nodeStack.push(node->right);
                if (node->left)
                    nodeStack.push(node->left);
            }
    }

    void postorder_it(node*p) {
        p = root;
        if (p == NULL)
            return;
        stack<node*> s1, s2;

        s1.push(root);
        node* node;

        while (!s1.empty()) {
            
            node = s1.top();
            s1.pop();
            s2.push(node);

            if (node->left)
                s1.push(node->left);
            if (node->right)
                s1.push(node->right);
        }

        while (!s2.empty()) {
            node = s2.top();
            s2.pop();
            cout << node->item << " ";
        }
    
    
    }

    void breadth_traversal(node* p) {
        p = root;
        if (p == NULL)
            return;
        queue<T> q;
        q.push(p);
        while (q.empty() == false) {
            node* temp = q.front();
            cout << temp->item << " ";
            q.pop();

            if (temp->left != NULL)
                q.push(temp->left);

            if (temp->right != NULL)
                q.push(temp->right);
        }
    
    }

    int size(node* p) {
        p = root;
        if (p == NULL)
            return 0;
        return 1 + size(p->left) + size(p->right);
    }
};

#endif
